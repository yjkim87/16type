<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBTI Interactive PDF Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // PDF.js 워커 설정
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        body {
            background-color: #f0f0f0;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: sans-serif;
        }

        #loader {
            margin-top: 50px;
            font-size: 1.2rem;
            color: #555;
        }

        /* --- 2페이지 (그리드 메뉴) 스타일 --- */
        #grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* 4열 */
            gap: 10px;
            max-width: 1000px;
            width: 95%;
            margin: 20px 0;
            background: white;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-radius: 10px;
            display: none; /* 로딩 전 숨김 */
        }

        .grid-cell {
            position: relative;
            cursor: pointer;
            overflow: hidden;
            border-radius: 8px;
            transition: transform 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .grid-cell canvas {
            width: 100%;
            height: auto;
            display: block;
        }

        /* 갸우뚱 애니메이션 */
        @keyframes wiggle {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(5deg); }
            100% { transform: rotate(0deg); }
        }

        .grid-cell:hover {
            animation: wiggle 0.4s ease-in-out infinite;
            z-index: 10;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }

        /* --- 상세 페이지 (3~18페이지) 스타일 --- */
        .page-container {
            max-width: 1000px;
            width: 95%;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .page-container canvas {
            width: 100%;
            height: auto;
            display: block;
        }

        /* 상단 이동 버튼 */
        .top-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background-color: #333;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            font-weight: bold;
            opacity: 0.7;
            transition: opacity 0.3s;
            z-index: 100;
        }
        .top-btn:hover { opacity: 1; }

    </style>
</head>
<body>

    <div id="loader">PDF 파일을 불러오는 중입니다...<br><small>(로컬 서버 환경인지 확인해주세요)</small></div>

    <div id="grid-container"></div>

    <div id="content-area"></div>

    <a href="#" class="top-btn">▲</a>

    <script>
        // PDF 파일 경로 (같은 폴더에 있어야 함)
        const url = 'MBTI.pdf';

        // --- [설정] 2페이지 자르기 좌표 조정 ---
        // PDF 2페이지 내에서 그리드가 시작되는 위치를 비율(0.0 ~ 1.0)로 조정합니다.
        // 만약 캐릭터 얼굴이 잘린다면 이 값들을 조금씩 수정하세요.
        const CROP_SETTINGS = {
            marginTop: 0.15,    // 위쪽 여백 (제목 등 제외)
            marginBottom: 0.10, // 아래쪽 여백 (페이지 번호 등 제외)
            marginLeft: 0.05,   // 왼쪽 여백
            marginRight: 0.05   // 오른쪽 여백
        };

        const gridContainer = document.getElementById('grid-container');
        const contentArea = document.getElementById('content-area');
        const loader = document.getElementById('loader');

        // PDF 로드 시작
        pdfjsLib.getDocument(url).promise.then(async function(pdf) {
            loader.style.display = 'none';
            gridContainer.style.display = 'grid';

            // 1. PAGE 2 처리 (그리드 자르기)
            await renderGridPage(pdf, 2);

            // 2. PAGE 3 ~ 18 처리 (통이미지 렌더링)
            // PDF 페이지 3 -> 상세페이지 ID: page3
            for (let i = 3; i <= 18; i++) { // 실제 PDF 페이지 범위
                if (i > pdf.numPages) break;
                await renderFullPage(pdf, i);
            }

        }).catch(function(error) {
            console.error('Error:', error);
            loader.innerHTML = "오류 발생: " + error.message + "<br>파일이 같은 폴더에 있는지, 로컬 서버(Live Server)를 사용 중인지 확인하세요.";
        });

        // 기능 1: 2페이지를 로드해서 16등분 캔버스로 자르는 함수
        async function renderGridPage(pdf, pageNum) {
            const page = await pdf.getPage(pageNum);
            const scale = 2.0; // 고해상도를 위해 2배 확대
            const viewport = page.getViewport({ scale: scale });

            // 임시 캔버스에 전체 페이지 그리기
            const tempCanvas = document.createElement('canvas');
            const context = tempCanvas.getContext('2d');
            tempCanvas.width = viewport.width;
            tempCanvas.height = viewport.height;

            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;

            // 자르기 계산
            const startX = viewport.width * CROP_SETTINGS.marginLeft;
            const endX = viewport.width * (1 - CROP_SETTINGS.marginRight);
            const startY = viewport.height * CROP_SETTINGS.marginTop;
            const endY = viewport.height * (1 - CROP_SETTINGS.marginBottom);

            const gridWidth = endX - startX;
            const gridHeight = endY - startY;
            
            const cellWidth = gridWidth / 4;
            const cellHeight = gridHeight / 4;

            // 16개 셀 생성 루프
            // 순서: ISTJ(p3) -> ISFJ(p4) ...
            let targetPage = 3; 

            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    // 각 셀을 위한 작은 캔버스 생성
                    const cellCanvas = document.createElement('canvas');
                    cellCanvas.width = cellWidth;
                    cellCanvas.height = cellHeight;
                    const cellCtx = cellCanvas.getContext('2d');

                    // 임시 캔버스에서 해당 영역만 복사해오기
                    const sourceX = startX + (col * cellWidth);
                    const sourceY = startY + (row * cellHeight);

                    cellCtx.drawImage(
                        tempCanvas, 
                        sourceX, sourceY, cellWidth, cellHeight, // 원본 좌표 및 크기
                        0, 0, cellWidth, cellHeight // 타겟 좌표 및 크기
                    );

                    // 링크 감싸기 (A태그)
                    const link = document.createElement('a');
                    link.className = 'grid-cell';
                    link.href = '#page-' + targetPage; // #page-3, #page-4 ...
                    
                    // 마지막 셀(P)인 경우 page 17이 아니라 18이거나 논리상 마지막 페이지로 매핑
                    // 요청하신 내용은 A=3p, B=4p... P=18p(순서대로) 입니다.
                    
                    link.appendChild(cellCanvas);
                    gridContainer.appendChild(link);

                    targetPage++;
                }
            }
        }

        // 기능 2: 페이지를 통째로 렌더링하는 함수 (상세 내용용)
        async function renderFullPage(pdf, pageNum) {
            const page = await pdf.getPage(pageNum);
            const scale = 1.5; // 적당한 크기
            const viewport = page.getViewport({ scale: scale });

            const div = document.createElement('div');
            div.className = 'page-container';
            div.id = 'page-' + pageNum; // 앵커 링크용 ID (예: page-3)

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = viewport.width;
            canvas.height = viewport.height;

            div.appendChild(canvas);
            contentArea.appendChild(div);

            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;
        }
    </script>
</body>
</html>
